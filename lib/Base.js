// Generated by CoffeeScript 1.6.3
(function() {
  var Base, Helpers, Q, fs, path;

  Helpers = require('./Helpers');

  path = require('path');

  fs = require('fs');

  Q = require('q');

  Base = (function() {
    Base.prototype.directory = null;

    Base.prototype.recursive = false;

    Base.prototype.excludes = null;

    Base.prototype.filters = null;

    Base.prototype.systemFiles = false;

    Base.prototype.up = false;

    Base.prototype.findFirst = false;

    Base.prototype._async = true;

    Base.prototype._data = null;

    function Base(directory) {
      directory = path.resolve(directory);
      if (!fs.statSync(directory).isDirectory()) {
        throw new Error("Path " + directory + " is not directory");
      }
      this.directory = directory;
      this.excludes = [];
      this.filters = [];
    }

    Base.mock = function(tree, info) {
      var FS;
      if (tree == null) {
        tree = {};
      }
      if (info == null) {
        info = {};
      }
      FS = require('fs-mock');
      fs = new FS(tree, info);
      return fs;
    };

    Base.restore = function() {
      return fs = require('fs');
    };

    Base.prototype.sync = function() {
      this._async = false;
      return this;
    };

    Base.prototype.async = function() {
      this._async = true;
      return this;
    };

    Base.prototype.recursively = function(recursive) {
      this.recursive = recursive != null ? recursive : true;
      return this;
    };

    Base.prototype.exclude = function(excludes) {
      var exclude, result, _i, _len;
      if (typeof excludes === 'string') {
        excludes = [excludes];
      }
      result = [];
      for (_i = 0, _len = excludes.length; _i < _len; _i++) {
        exclude = excludes[_i];
        result.push(Helpers.normalizePattern(exclude));
      }
      this.excludes = this.excludes.concat(result);
      return this;
    };

    Base.prototype.showSystemFiles = function(systemFiles) {
      this.systemFiles = systemFiles != null ? systemFiles : true;
      return this;
    };

    Base.prototype.lookUp = function(up) {
      this.up = up != null ? up : true;
      return this;
    };

    Base.prototype.findFirst = function(findFirst) {
      this.findFirst = findFirst != null ? findFirst : true;
      return this;
    };

    Base.prototype.filter = function(fn) {
      this.filters.push(fn);
      return this;
    };

    Base.prototype.getPathsSync = function(type, mask, dir) {
      var err, paths, read, result, stats, _i, _len, _path;
      if (type == null) {
        type = 'all';
      }
      if (mask == null) {
        mask = null;
      }
      if (dir == null) {
        dir = this.directory;
      }
      paths = [];
      try {
        read = fs.readdirSync(dir);
      } catch (_error) {
        err = _error;
        if (this.findFirst === true) {
          return null;
        }
        return paths;
      }
      for (_i = 0, _len = read.length; _i < _len; _i++) {
        _path = read[_i];
        _path = path.join(dir, _path);
        if (!this.checkExcludes(_path) || !this.checkSystemFiles(_path)) {
          continue;
        }
        try {
          stats = fs.statSync(_path);
        } catch (_error) {
          err = _error;
          continue;
        }
        switch (this.checkFile(_path, stats, mask, type)) {
          case 0:
            continue;
          case 1:
            if (this.findFirst === true) {
              return _path;
            }
            paths.push(_path);
        }
        if (stats.isDirectory() && this.recursive === true) {
          result = this.getPathsSync(type, mask, _path);
          if (this.findFirst === true && typeof result === 'string') {
            return result;
          } else if (this.findFirst === true && result === null) {
            continue;
          } else {
            paths = paths.concat(result);
          }
        }
      }
      if (this.findFirst === true) {
        return null;
      } else {
        return paths;
      }
    };

    Base.prototype.getPathsAsync = function(type, mask, dir) {
      var deferred, result,
        _this = this;
      if (type == null) {
        type = 'all';
      }
      if (mask == null) {
        mask = null;
      }
      if (dir == null) {
        dir = this.directory;
      }
      deferred = Q.defer();
      result = [];
      Q.nfcall(fs.readdir, dir).then(function(paths) {
        var _i, _len, _path, _results;
        _results = [];
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          _path = paths[_i];
          _path = path.join(dir, _path);
          if (!_this.checkExcludes(_path) || !_this.checkSystemFiles(_path)) {
            continue;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }).fail(function() {
        return deferred.resolve(_this.findFiles === true ? null : []);
      });
      return deferred.promise;
    };

    Base.prototype.checkExcludes = function(_path) {
      var exclude, _i, _len, _ref;
      _ref = this.excludes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        exclude = _ref[_i];
        if ((new RegExp(exclude)).test(_path)) {
          return false;
        }
      }
      return true;
    };

    Base.prototype.checkSystemFiles = function(_path) {
      if (this.systemFiles === false) {
        if (path.basename(_path)[0] === '.' || _path.match(/~$/) !== null) {
          return false;
        }
      }
      return true;
    };

    Base.prototype.checkFilters = function(_path, stats) {
      var filter, _i, _len, _ref;
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filter = _ref[_i];
        if (!filter(stats, _path)) {
          return false;
        }
      }
      return true;
    };

    Base.prototype.checkFile = function(_path, stats, mask, type) {
      if (type === 'all' || (type === 'files' && stats.isFile()) || (type === 'directories' && stats.isDirectory())) {
        if (mask === null || (mask !== null && (new RegExp(mask, 'g')).test(_path))) {
          if (!this.checkFilters(_path, stats)) {
            return 0;
          }
          return 1;
        }
      }
      return 2;
    };

    Base.prototype.getPathsFromParentsSync = function(mask, type) {
      var depth, directory, i, match, paths, result, _i, _ref;
      if (mask == null) {
        mask = null;
      }
      if (type == null) {
        type = 'all';
      }
      directory = this.directory;
      paths = this.getPathsSync(type, mask, directory);
      if (this.findFirst === true && typeof paths === 'string') {
        return paths;
      }
      this.exclude(directory);
      if (this.up === true) {
        depth = directory.match(/\//g).length;
      } else if (typeof this.up === 'string') {
        if (this.up === directory) {
          if (this.findFirst === true) {
            return null;
          } else {
            return paths;
          }
        }
        match = path.relative(this.up, directory).match(/\//g);
        depth = match === null ? 2 : match.length + 2;
      } else {
        depth = this.up - 1;
      }
      for (i = _i = 0, _ref = depth - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        directory = path.dirname(directory);
        result = this.getPathsSync(type, mask, directory);
        if (this.findFirst === true && typeof result === 'string') {
          return result;
        } else if (this.findFirst === true && result === null) {

        } else {
          paths = paths.concat(result);
        }
        this.exclude(directory);
      }
      if (this.findFirst === true) {
        return null;
      } else {
        return paths;
      }
    };

    return Base;

  })();

  module.exports = Base;

}).call(this);
