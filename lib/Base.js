// Generated by CoffeeScript 1.6.3
(function() {
  var Base, Helpers, fs, path;

  Helpers = require('./Helpers');

  path = require('path');

  fs = require('fs');

  Base = (function() {
    Base.prototype.directory = null;

    Base.prototype.recursive = false;

    Base.prototype.excludes = null;

    Base.prototype.filters = null;

    Base.prototype.systemFiles = false;

    Base.prototype.up = false;

    Base.prototype.findFirst = false;

    function Base(directory) {
      directory = path.resolve(directory);
      if (!fs.statSync(directory).isDirectory()) {
        throw new Error("Path " + directory + " is not directory");
      }
      this.directory = directory;
      this.excludes = [];
      this.filters = [];
    }

    Base.mock = function(tree, info) {
      var FS;
      if (tree == null) {
        tree = {};
      }
      if (info == null) {
        info = {};
      }
      FS = require('fs-mock');
      fs = new FS(tree, info);
      return fs;
    };

    Base.restore = function() {
      return fs = require('fs');
    };

    Base.prototype.recursively = function(recursive) {
      this.recursive = recursive != null ? recursive : true;
      return this;
    };

    Base.prototype.exclude = function(excludes) {
      var exclude, result, _i, _len;
      if (typeof excludes === 'string') {
        excludes = [excludes];
      }
      result = [];
      for (_i = 0, _len = excludes.length; _i < _len; _i++) {
        exclude = excludes[_i];
        result.push(Helpers.normalizePattern(exclude));
      }
      this.excludes = this.excludes.concat(result);
      return this;
    };

    Base.prototype.showSystemFiles = function(systemFiles) {
      this.systemFiles = systemFiles != null ? systemFiles : true;
      return this;
    };

    Base.prototype.lookUp = function(up) {
      this.up = up != null ? up : true;
      return this;
    };

    Base.prototype.findFirst = function(findFirst) {
      this.findFirst = findFirst != null ? findFirst : true;
      return this;
    };

    Base.prototype.filter = function(fn) {
      this.filters.push(fn);
      return this;
    };

    Base.prototype.getPathsSync = function(type, mask, dir) {
      var err, exclude, filter, ok, paths, read, result, stat, _i, _j, _k, _len, _len1, _len2, _path, _ref, _ref1;
      if (type == null) {
        type = 'all';
      }
      if (mask == null) {
        mask = null;
      }
      if (dir == null) {
        dir = this.directory;
      }
      paths = [];
      try {
        read = fs.readdirSync(dir);
      } catch (_error) {
        err = _error;
        throw err;
        if (this.findFirst === true) {
          return null;
        } else {
          return paths;
        }
      }
      for (_i = 0, _len = read.length; _i < _len; _i++) {
        _path = read[_i];
        _path = path.join(dir, _path);
        ok = true;
        _ref = this.excludes;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          exclude = _ref[_j];
          if ((new RegExp(exclude)).test(_path)) {
            ok = false;
            break;
          }
        }
        if (ok === false) {
          continue;
        }
        if (this.systemFiles === false) {
          if (path.basename(_path)[0] === '.') {
            continue;
          }
          if (_path.match(/~$/) !== null) {
            continue;
          }
        }
        try {
          stat = fs.statSync(_path);
        } catch (_error) {
          err = _error;
          continue;
        }
        if (type === 'all' || (type === 'files' && stat.isFile()) || (type === 'directories' && stat.isDirectory())) {
          if (mask === null || (mask !== null && (new RegExp(mask, 'g')).test(_path))) {
            ok = true;
            _ref1 = this.filters;
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              filter = _ref1[_k];
              if (!filter(stat, _path)) {
                ok = false;
                break;
              }
            }
            if (ok === false) {
              continue;
            }
            if (this.findFirst === true) {
              return _path;
            }
            paths.push(_path);
          }
        }
        if (stat.isDirectory() && this.recursive === true) {
          result = this.getPathsSync(type, mask, _path);
          if (this.findFirst === true && typeof result === 'string') {
            return result;
          } else if (this.findFirst === true && result === null) {
            continue;
          } else {
            paths = paths.concat(result);
          }
        }
      }
      if (this.findFirst === true) {
        return null;
      } else {
        return paths;
      }
    };

    Base.prototype.getPathsFromParentsSync = function(mask, type) {
      var depth, directory, i, match, paths, result, _i, _ref;
      if (mask == null) {
        mask = null;
      }
      if (type == null) {
        type = 'all';
      }
      directory = this.directory;
      paths = this.getPathsSync(type, mask, directory);
      if (this.findFirst === true && typeof paths === 'string') {
        return paths;
      }
      this.exclude(directory);
      if (this.up === true) {
        depth = directory.match(/\//g).length;
      } else if (typeof this.up === 'string') {
        if (this.up === directory) {
          if (this.findFirst === true) {
            return null;
          } else {
            return paths;
          }
        }
        match = path.relative(this.up, directory).match(/\//g);
        depth = match === null ? 2 : match.length + 2;
      } else {
        depth = this.up - 1;
      }
      for (i = _i = 0, _ref = depth - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        directory = path.dirname(directory);
        result = this.getPathsSync(type, mask, directory);
        if (this.findFirst === true && typeof result === 'string') {
          return result;
        } else if (this.findFirst === true && result === null) {

        } else {
          paths = paths.concat(result);
        }
        this.exclude(directory);
      }
      if (this.findFirst === true) {
        return null;
      } else {
        return paths;
      }
    };

    return Base;

  })();

  module.exports = Base;

}).call(this);
