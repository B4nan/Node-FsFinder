// Generated by CoffeeScript 1.6.3
(function() {
  var Finder, compare, fs, moment, _path;

  fs = require('fs');

  _path = require('path');

  moment = require('moment');

  compare = require('operator-compare');

  Finder = (function() {
    Finder.ASTERISK_PATTERN = '<[0-9a-zA-Z/.-_ ]+>';

    Finder.ESCAPE_PATTERN = ['.', '[', ']', '\\', '^', '$', '|', '?', '+', '(', ')', '{', '}'];

    Finder.TIME_FORMAT = 'YYYY-MM-DD HH:mm';

    Finder.prototype.directory = null;

    Finder.prototype.recursive = false;

    Finder.prototype.excludes = null;

    Finder.prototype.filters = null;

    Finder.prototype.systemFiles = false;

    Finder.prototype.up = false;

    Finder.prototype.findFirst = false;

    function Finder(directory) {
      directory = _path.resolve(directory);
      if (!fs.statSync(directory).isDirectory()) {
        throw new Error("Path " + directory + " is not directory");
      }
      this.directory = directory;
      this.excludes = [];
      this.filters = [];
    }

    Finder.prototype.recursively = function(recursive) {
      this.recursive = recursive != null ? recursive : true;
      return this;
    };

    Finder.prototype.exclude = function(excludes) {
      var exclude, result, _i, _len;
      if (typeof excludes === 'string') {
        excludes = [excludes];
      }
      result = [];
      for (_i = 0, _len = excludes.length; _i < _len; _i++) {
        exclude = excludes[_i];
        result.push(Finder.normalizePattern(exclude));
      }
      this.excludes = this.excludes.concat(result);
      return this;
    };

    Finder.prototype.size = function(operation, value) {
      this.filter(function(stat) {
        return compare(stat.size, operation, value);
      });
      return this;
    };

    Finder.prototype.date = function(operation, value) {
      this.filter(function(stat) {
        var date;
        switch (Object.prototype.toString.call(value)) {
          case '[object String]':
            date = moment(value, Finder.TIME_FORMAT);
            break;
          case '[object Object]':
            date = moment().subtract(value);
            break;
          default:
            throw new Error('Date format is not valid.');
        }
        return compare((new Date(stat.mtime)).getTime(), operation, date.valueOf());
      });
      return this;
    };

    Finder.prototype.showSystemFiles = function(systemFiles) {
      this.systemFiles = systemFiles != null ? systemFiles : true;
      return this;
    };

    Finder.prototype.lookUp = function(up) {
      this.up = up != null ? up : true;
      return this;
    };

    Finder.prototype.findFirst = function(findFirst) {
      this.findFirst = findFirst != null ? findFirst : true;
      return this;
    };

    Finder.prototype.filter = function(fn) {
      this.filters.push(fn);
      return this;
    };

    Finder.prototype.getPaths = function(dir, type, mask) {
      var err, exclude, filter, ok, path, paths, read, result, stat, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      if (type == null) {
        type = 'all';
      }
      if (mask == null) {
        mask = null;
      }
      paths = [];
      try {
        read = fs.readdirSync(dir);
      } catch (_error) {
        err = _error;
        if (this.findFirst === true) {
          return null;
        } else {
          return paths;
        }
      }
      for (_i = 0, _len = read.length; _i < _len; _i++) {
        path = read[_i];
        path = dir + '/' + path;
        ok = true;
        _ref = this.excludes;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          exclude = _ref[_j];
          if ((new RegExp(exclude)).test(path)) {
            ok = false;
            break;
          }
        }
        if (ok === false) {
          continue;
        }
        if (this.systemFiles === false) {
          if (_path.basename(path)[0] === '.') {
            continue;
          }
          if (path.match(/~$/) !== null) {
            continue;
          }
        }
        try {
          stat = fs.statSync(path);
        } catch (_error) {
          err = _error;
          continue;
        }
        if (type === 'all' || (type === 'files' && stat.isFile()) || (type === 'directories' && stat.isDirectory())) {
          if (mask === null || (mask !== null && (new RegExp(mask, 'g')).test(path))) {
            ok = true;
            _ref1 = this.filters;
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              filter = _ref1[_k];
              if (!filter(stat, path)) {
                ok = false;
                break;
              }
            }
            if (ok === false) {
              continue;
            }
            if (this.findFirst === true) {
              return path;
            }
            paths.push(path);
          }
        }
        if (stat.isDirectory() && this.recursive === true) {
          result = this.getPaths(path, type, mask);
          if (this.findFirst === true && typeof result === 'string') {
            return result;
          } else if (this.findFirst === true && result === null) {
            continue;
          } else {
            paths = paths.concat(result);
          }
        }
      }
      if (this.findFirst === true) {
        return null;
      } else {
        return paths;
      }
    };

    Finder.prototype.getPathsFromParents = function(mask, type) {
      var depth, directory, i, paths, result, _i, _ref;
      if (mask == null) {
        mask = null;
      }
      if (type == null) {
        type = 'all';
      }
      directory = this.directory;
      paths = this.getPaths(directory, type, mask);
      if (this.findFirst === true && typeof paths === 'string') {
        return paths;
      }
      if (this.up === true) {
        depth = directory.match(/\//g).length;
      } else if (typeof this.up === 'string') {
        depth = _path.relative(this.up, directory).match(/\//g).length + 2;
      } else {
        depth = this.up - 1;
      }
      this.exclude(directory);
      for (i = _i = 0, _ref = depth - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        directory = _path.dirname(directory);
        result = this.getPaths(directory, type, mask);
        if (this.findFirst === true && typeof result === 'string') {
          return result;
        } else if (this.findFirst === true && result === null) {

        } else {
          paths = paths.concat(result);
        }
        this.exclude(directory);
      }
      if (this.findFirst === true) {
        return null;
      } else {
        return paths;
      }
    };

    Finder.prototype.find = function(mask, type) {
      var _ref;
      if (mask == null) {
        mask = null;
      }
      if (type == null) {
        type = 'all';
      }
      mask = Finder.normalizePattern(mask);
      if (this.up === true || ((_ref = typeof this.up) === 'number' || _ref === 'string')) {
        return this.getPathsFromParents(mask, type);
      } else {
        return this.getPaths(this.directory, type, mask);
      }
    };

    Finder.prototype.findFiles = function(mask) {
      if (mask == null) {
        mask = null;
      }
      return this.find(mask, 'files');
    };

    Finder.prototype.findDirectories = function(mask) {
      if (mask == null) {
        mask = null;
      }
      return this.find(mask, 'directories');
    };

    Finder["in"] = function(path) {
      return new Finder(path);
    };

    Finder.from = function(path) {
      return (new Finder(path)).recursively();
    };

    Finder.find = function(path, type) {
      if (type == null) {
        type = 'all';
      }
      path = this.parseDirectory(path);
      return (new Finder(path.directory)).recursively().find(path.mask, type);
    };

    Finder.findFiles = function(path) {
      return Finder.find(path, 'files');
    };

    Finder.findDirectories = function(path) {
      return Finder.find(path, 'directories');
    };

    Finder.parseDirectory = function(path) {
      var asterisk, mask, regexp, splitter;
      mask = null;
      asterisk = path.indexOf('*');
      regexp = path.indexOf('<');
      if (asterisk !== -1 || regexp !== -1) {
        if (asterisk === -1 || (asterisk !== -1 && regexp !== -1 && asterisk > regexp)) {
          splitter = regexp;
        } else if (regexp === -1 || (regexp !== -1 && asterisk !== -1 && asterisk <= regexp)) {
          splitter = asterisk;
        }
        mask = path.substr(splitter);
        path = path.substr(0, splitter);
      }
      return {
        directory: path,
        mask: mask
      };
    };

    Finder.normalizePattern = function(pattern) {
      var i, part, parts, partsResult, replacement, _i, _len;
      if (pattern === null) {
        return null;
      }
      if (pattern === '*') {
        return null;
      }
      pattern = pattern.replace(/\*/g, Finder.ASTERISK_PATTERN);
      parts = pattern.match(/<((?!(<|>)).)*>/g);
      if (parts !== null) {
        partsResult = {};
        for (i = _i = 0, _len = parts.length; _i < _len; i = ++_i) {
          part = parts[i];
          partsResult['::' + i + '::'] = part.replace(/^<(.*)>$/, '$1');
          pattern = pattern.replace(part, '::' + i + '::');
        }
        pattern = Finder.escapeForRegex(pattern);
        for (replacement in partsResult) {
          part = partsResult[replacement];
          pattern = pattern.replace(replacement, part);
        }
      } else {
        pattern = Finder.escapeForRegex(pattern);
      }
      return pattern;
    };

    Finder.escapeForRegex = function(text) {
      var char, replace, _i, _len, _ref;
      replace = [];
      _ref = Finder.ESCAPE_PATTERN;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        char = _ref[_i];
        replace.push('\\' + char);
      }
      return text.replace(new RegExp('(' + replace.join('|') + ')', 'g'), '\\$1');
    };

    return Finder;

  })();

  module.exports = Finder;

}).call(this);
